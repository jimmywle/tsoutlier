{
    "collab_server" : "",
    "contents" : "#' @title newfunction1\n#' @description newfunction1\n#' @export\n#' @import tsoutliers\noutlier_detection<- function(y, xreg = NULL, cval = NULL, delta = 0.7, n.start = 50,\n                             types = c(\"AO\", \"LS\", \"TC\"), # c(\"IO\", \"AO\", \"LS\", \"TC\", \"SLS\")\n                             maxit = 1, maxit.iloop = 4, cval.reduce = 0.14286,\n                             remove.method = c(\"en-masse\", \"bottom-up\"),\n                             remove.cval = NULL,\n                             tsmethod = c(\"auto.arima\", \"arima\", \"stsm\"),\n                             args.tsmethod = NULL, args.tsmodel = NULL, logfile = NULL)\n{\n  tsmethod <- match.arg(tsmethod)\n  remove.method <- match.arg(remove.method)\n  attr.y <- attributes(y)\n  n <- length(y)\n  yname <- deparse(substitute(y))\n  #stopifnot(is.ts(y))\n\n  if (!is.null(args.tsmethod$xreg))\n  {\n    xreg <- args.tsmethod$xreg\n    args.tsmethod$xreg <- NULL # this removes element \"xreg\" from the list\n\n  }\n\n  if (tsmethod == \"stsm\")\n  {\n    if (is.null(args.tsmodel$model))\n      args.tsmodel$model <- ifelse(frequency(y) == 1, \"local-level\", \"BSM\")\n\n    ##FIXME these defaults only if stsm.method = \"maxlik.fd.scoring\"\n\n    if (is.null(args.tsmodel$ssd))\n      args.tsmodel$ssd <- TRUE\n    if (is.null(args.tsmodel$sgfc))\n      args.tsmodel$sgfc <- TRUE\n    # let \"stsm::stsmFit\" handle \"xreg\", not here\n    y <- do.call(\"stsm.model\", args = c(list(y = y), args.tsmodel))\n    #ylist <- list(m = m)\n  }\n  if (is.null(args.tsmethod))\n  {\n    args.tsmethod <- switch(tsmethod,\n                            \"auto.arima\" = list(allowdrift = FALSE, ic = \"bic\"),\n                            \"arima\" = list(order = c(0, 1, 1), seasonal = list(order = c(0, 1, 1))),\n                            \"stsm\" = list(stsm.method = \"maxlik.td.optim\", method = \"L-BFGS-B\",\n                                          KF.version = \"KFKSDS\", KF.args = list(P0cov = TRUE), gr = \"numerical\")) #hessian = TRUE\n    #list(stsm.method = \"maxlik.fd.scoring\", step = NULL, information = \"expected\"))\n  }\n\n  # default critical value\n  # the same is done in functions \"locate.outliers.oloop\" and \"remove.outliers\"\n  # \"cval\" is passed as a non-null value from tso() to those functions\n  # but keep there this block so that default value is used when those functions\n  # are called outside tso()\n\n  if (is.null(cval))\n  {\n    #n <- length(y)\n    if (n <= 50) {\n      cval <- 3\n    } else\n      if (n >= 450) {\n        cval <- 4\n      } else\n        cval <- round(3 + 0.0025 * (n - 50), 2)\n  }\n\n  cval0 <- cval\n  if (is.null(remove.cval))\n    remove.cval <- cval\n\n  # \"res0\" is used below to generate the output,\n  # \"res\" is overwritten until no more outliers are found\n  # \"res0\" is also used if maxit = 1\n\n  res0 <- res <- tso0(x = y, xreg = xreg, cval = cval,\n                      delta = delta, n.start = n.start,\n                      types = types, maxit.iloop = maxit.iloop,\n                      remove.method = remove.method, remove.cval = remove.cval,\n                      tsmethod = tsmethod, args.tsmethod = args.tsmethod,\n                      logfile = logfile)\n\n  fit.wo.outliers <- res$fit0 # model without outliers (if maxit>1 res0 may change)\n  moall <- res$outliers\n  outtimes <- res$times\n\n  iter <- 1\n  cval <- round(cval * (1 - cval.reduce), 2)\n\n  if (nrow(moall) > 1)\n    while (iter < maxit)\n    {\n      ##FIXME see move res0 <- res after if(...) break\n\n      if (tsmethod == \"stsm\")\n      {\n        ##FIXME TODO create stsm object based on res$yadj as done above\n        warning(\"currently \", sQuote(\"maxit\"), \" > 1 is not allowed for \", sQuote(\"tsmethod=\\\"stsm\\\"\"))\n        break\n      }\n      # save \"res\" to have a copy of the last fitted model, res$fit;\n      # if in the current run no outliers are found then\n      # tso0() does not return the fitted model\n\n      res0 <- res\n\n      res <- tso0(x = res$yadj, xreg = xreg, cval = cval,\n                  delta = delta, n.start = n.start,\n                  types = types, maxit.iloop = maxit.iloop,\n                  remove.method = remove.method, remove.cval = remove.cval,\n                  tsmethod = tsmethod, args.tsmethod = args.tsmethod,\n                  logfile = logfile)\n\n      ##FIXME check\n      #discard (remove) duplicates and outliers at consecutive type points (if any)\n      #\n      #do not discard according to abs(t-stat) because the detection of outliers\n      #are based on res$yadj (not the original series); discarding an outlier\n      #from a previous iteration would require changing the current res$yadj\n      #\n      #discard outliers at an observation where an outlier (of the same or other type)\n      #was detected in a previous iteration\n      id <- which(res$outliers[,\"ind\"] %in% res0$outliers[,\"ind\"])\n      if (length(id) > 0)\n        res$outliers <- res$outliers[id,]\n      #discard consecutive outliers of any type, keep the outlier from previous iterations\n      id <- which(apply(outer(res$outliers[,\"ind\"], res0$outliers[,\"ind\"], \"-\"), MARGIN=1,\n                        FUN = function(x) any(x == 1)))\n      if (length(id) > 0)\n        res$outliers <- res$outliers[id,]\n\n      if (nrow(res$outliers) == 0)\n        break\n\n      moall <- rbind(moall, res$outliers)\n      outtimes <- c(outtimes, res$times)\n\n      iter <- iter + 1\n    }\n\n  # final model given the detected outliers\n  ######################################################################\n  if (nrow(moall) > 0)\n  {\n    #NOTE 'pars' is relevant only for innovational outliers,\n    #when 'maxit'>1, see if it would be better to use 'res' instead of 'res0',\n    #preferably it should be based on 'pars' from a model for the original data\n    #rather than the series adjusted for outliers\n\n    pars <- switch(tsmethod,\n                   \"auto.arima\" = , \"arima\" = coefs2poly(res0$fit),\n                   \"stsm\" = stsm::char2numeric(res0$fit$model))\n\n    # 'xreg': input regressor variables such as calendar effects (if any)\n    # 'xreg.outl': outliers regressor variables detected above (if any)\n    # 'xregall': all regressors ('xreg' and 'xreg.outl')\n\n    xreg.outl <- outliers.effects(mo = moall, n = n, weights = FALSE, delta = delta,\n                                  pars = pars, n.start = n.start, freq = frequency(y))\n    xregall <- cbind(xreg, xreg.outl)\n    nms.outl <- colnames(xreg.outl)\n    colnames(xregall) <- c(colnames(xreg), nms.outl)\n\n    ##NOTE\n    # rerunning \"auto.arima\" (model selection) may not be necessary at this point\n\n    if (tsmethod == \"stsm\") {\n      fit <- do.call(\"stsmFit\", args = c(list(x = y, xreg = xregall), args.tsmethod))\n    } else {\n      fit <- do.call(tsmethod, args = c(list(x = y, xreg = xregall), args.tsmethod))\n      # this is for proper printing of results from \"auto.arima\" and \"arima\"\n      fit$series <- yname\n    }\n\n    id <- colnames(xreg.outl)\n    if (tsmethod == \"stsm\")\n    {\n      xregcoefs <- fit$pars[id]\n      tstats <- xregcoefs / fit$std.errors[id]\n    } else { # method \"auto.arima\", \"arima\"\n      xregcoefs <- coef(fit)[id]\n      tstats <- xregcoefs / sqrt(diag(fit$var.coef)[id])\n    }\n\n    moall[,\"coefhat\"] <- xregcoefs\n    moall[,\"tstat\"] <- tstats\n\n\n\n\n  }\n  moall\n}\n\ntso0 <- function(x, xreg = NULL, cval = 3.5, delta = 0.7, n.start = 50,\n                 types = c(\"AO\", \"LS\", \"TC\"), maxit.iloop = 4,\n                 remove.method = c(\"en-masse\", \"bottom-up\"),\n                 remove.cval = NULL,\n                 tsmethod = c(\"auto.arima\", \"arima\", \"stsm\"), args.tsmethod = NULL,\n                 args.tsmodel = NULL, logfile = NULL)\n{\n  # \"x\" can be either a \"ts\" object or a \"stsm\" object;\n  # if !inherits(x, \"stsm\") then two identical objects are stored (\"x\" and \"y\")\n\n  y <- if(is.ts(x)) { x } else x@y\n\n  #remove.method <- match.arg(remove.method)\n  #tsmethod <- match.arg(tsmethod)\n  #remove.method <- match.arg(remove.method)\n  fitmethod <- gsub(\"stsm\", \"stsmFit\", tsmethod)\n\n  if (is.null(remove.cval))\n    remove.cval <- cval\n\n  # fit time series model\n\n  fit.wo.outliers <-\n    fit <- do.call(fitmethod, args = c(list(x = x, xreg = xreg), args.tsmethod))\n  #fit$series <- deparse(substitute(y))\n\n  if (!is.null(logfile))\n  {\n    cat(paste(\"model selection:\\n\"), file = logfile, append = FALSE)\n    capture.output(fit, file = logfile, append = TRUE)\n  }\n\n  # identify and locate prospective outliers by type\n  # given a fitted time series model\n\n  stage1 <- locate.outliers.oloop(y = y, fit = fit, types = types, cval = cval,\n                                  maxit.iloop = maxit.iloop, delta = delta, n.start = n.start, logfile = logfile)\n\n  # choose and fit the model including the outlier regressors detected so far\n  # (the weights of the outliers is fine tuned, to see it\n  # compare 'moall[,\"coefhat\"]' with 'coef(fit)[\"oeffi\"]') then\n  # remove the outliers detected so far if they are not significant in the new model/fit\n\n  if (nrow(stage1$outliers) > 0)\n  {\n    stage2 <- remove.outliers(x = stage1, y = y, cval = remove.cval,\n                              method = remove.method, delta = delta, n.start = n.start,\n                              tsmethod.call = fit$call, fdiff = NULL, logfile = logfile)\n\n    #moall <- stage2$outliers\n    stopifnot(ncol(stage2$xreg) == length(stage2$xregcoefs))\n  } else\n    stage2 <- list(xreg = NULL, fit = stage1$fit)\n\n  # final outliers and\n  # original series adjusted for the outlier effects\n\n  if (!is.null(stage2$xreg))\n  {\n    # stage2$fit$xreg is not returned by arima()\n    moall <- stage2$outliers\n    ##NOTE changed 2016Nov12 after changes in remove.outliers(), \"moall\" is updated there\n    #moall[,\"coefhat\"] <- stage2$xregcoefs\n    #moall[,\"tstat\"] <- stage2$xregtstats\n\n    oeff <- stage2$xreg %*% cbind(stage2$xregcoefs)\n    attributes(oeff) <- attributes(y)\n    yadj <- y - oeff\n\n    moall <- moall[,c(\"type\", \"ind\", \"coefhat\", \"tstat\")]\n    outtimes <- time(y)[moall[,\"ind\"]]\n    if (frequency(y) > 1)\n      outseason <- formatC(as.vector(cycle(y)[moall[,\"ind\"]]),\n                           width = 2, flag=\"0\")\n\n    moall <- cbind(moall[,c(\"type\", \"ind\")],\n                   \"time\" = if (frequency(y) > 1) paste(floor(outtimes),\n                                                        outseason, sep = \":\") else outtimes,\n                   moall[,c(\"coefhat\",\"tstat\")])\n\n    oind <- order(moall[,\"ind\"])\n    moall <- moall[oind,]\n    outtimes <- outtimes[oind]\n    rownames(moall) <- NULL\n\n  } else { # no outliers detected\n    oeff <- NULL\n    yadj <- y\n    moall <- data.frame(array(dim = c(0, 4)))\n    colnames(moall) <- c(\"type\", \"ind\", \"coefhat\", \"tstat\")\n    outtimes <- NULL\n  }\n\n  if (!is.null(logfile))\n  {\n    msg <- paste(\"\\nfinal outliers\\n\")\n    cat(msg, file = logfile, append = TRUE)\n    capture.output(moall, file = logfile, append = TRUE)\n  }\n\n  structure(list(outliers = moall, y = y, yadj = yadj, cval = cval,\n                 fit0 = fit.wo.outliers, # initial model fitted without outliers\n                 fit = stage2$fit, effects = oeff, times = outtimes),\n            class = \"tsoutliers\")\n}\n\nlocate.outliers.oloop <- function(y, fit, types = c(\"AO\", \"LS\", \"TC\"),\n                                  cval = NULL, maxit.iloop = 4, delta = 0.7, n.start = 50, logfile = NULL)\n{\n  maxit <- 4 # maxit.oloop\n  n <- length(y)\n  s <- frequency(y)\n\n  if (is.null(cval))\n  {\n    if (n <= 50) {\n      cval <- 3\n    } else\n      if (n >= 450) {\n        cval <- 4\n      } else\n        cval <- round(3 + 0.0025 * (n - 50), 2)\n  }\n\n  # tail(): take the last element just in case fit$call[[1]] is\n  # for example \"forecast::auto.arima\"\n  tsmethod <- ifelse(inherits(fit, \"stsmFit\"),\n                     \"stsm\", tail(as.character(fit$call[[1]]), 1))\n  #s <- frequency(y)\n  moall <- data.frame(matrix(nrow = 0, ncol=4,\n                             dimnames = list(NULL, c(\"type\", \"ind\", \"coefhat\", \"tstat\"))))\n  iter <- 0\n\n  # index of initial residuals\n\n  if (inherits(fit, \"Arima\")) {\n    tmp <- fit$arma[6] + fit$arma[5] * fit$arma[7]\n    id0resid <- if (tmp > 1) seq.int(tmp) else c(1, 2)\n  } else\n    if (inherits(fit, \"stsmFit\")) {\n      id0resid <- seq_len(n - length(fit$model@diffy))\n    } else\n      stop(\"unexpected type of fitted model\")\n\n  # begin outer loop\n\n  #while (TRUE)\n  while (iter < maxit)\n  {\n    # extract the necessary information from the fitted model\n    # parameter estimates and residuals\n\n    pars <- switch(tsmethod,\n                   \"auto.arima\" = , \"arima\" = coefs2poly(fit),\n                   \"stsm\" = stsm::char2numeric(fit$model))\n\n    ##NOTE by default residuals(fit, standardised = FALSE)\n    # only relevant for \"stsm\" but the argument could set here\n    # explicitly, it would be ignored if \"fit\" is an \"Arima\" object\n    resid <- residuals(fit)\n\n    if (any(abs(na.omit(resid[id0resid])) > 3.5 * sd(resid[-id0resid], na.rm = TRUE)))\n    {\n      ##FIXME\n      # see add factor 3.5 as argument\n\n      # this was necessary since in one series (I think it was hicp[[\"000000\"]])\n      # the first residuals were too erratic and caused the procedure to detect\n      # too many outliers in the whole series\n\n      resid[id0resid] <- 0\n      # warning(paste(\"the first\", tail(id0resid, 1), \"residuals were set to zero\"))\n\n      ##NOTE\n      # if this warning is returned\n      # the first observations of the series may need to be inspected\n      # for possible outliers, since those observations were ignored by the procedure\n    }\n\n    # locate possible outliers\n\n    mo <- locate.outliers.iloop(resid = resid, pars = pars, cval = cval,\n                                types = types, maxit = maxit.iloop, delta = delta, n.start = n.start,\n                                logfile = logfile)\n\n    # discard outliers identified at consecutive time points (if any)\n    #\n    # this is done by type of outlier, e.g., two or more consecutive LS are\n    # replaced by one LS (the one with the highest abs(t-statistic);\n    # it is still possible to get two or more consecutive outliers of different\n    # type at consecutive time points;\n    # alternatively consecutive outliers of any type could be replaced by a\n    # single outlier. For the time being, this is kept in this way so that\n    # for example, the following sequence AO1,LS2,LS3,LS4 can collapse to\n    # AO1,LS4, i.e., the AO is kept\n    #\n    # it is not enough to do this in locate.outliers.iloop(), because\n    # only the outliers detected at a given interation are checked there;\n    # here, the whole set of outliers returned by locate.outliers.iloop()\n    # is checked\n\n    if (nrow(mo) > 0)\n    {\n      rmid <- c(\n        find.consecutive.outliers(mo, \"IO\"),\n        find.consecutive.outliers(mo, \"AO\"),\n        find.consecutive.outliers(mo, \"LS\"),\n        find.consecutive.outliers(mo, \"TC\"),\n        find.consecutive.outliers(mo, \"SLS\"))\n      #rmid <- NULL\n      #for (type in types)\n      #  rmid <- c(rmid, find.consecutive.outliers(mo, type))\n\n      if (length(rmid) > 0)\n        # do not use is.null(rmid), 'rmid' may be NULL or 'character(0)'\n      {\n        #changed in version 0.6-4\n        #mo <- mo[-as.numeric(rownames(mo[rmid,])),]\n        #mo <- mo[-match(as.numeric(rownames(mo[rmid,])), rownames(mo)),]\n        #changed in version 0.6-5\n        mo <- mo[-rmid,]\n      }\n    }\n\n    # remove duplicates (if any)\n    # similar to locate.outliers.iloop(), if an outlier is detected at\n    # an observation where some type of outliers was already detected in\n    # a previous run, the outlier that was detected first is kept\n\n    if (nrow(mo) > 0 && iter > 0)\n    {\n      id.dups <- na.omit(match(moall[,\"ind\"], mo[,\"ind\"]))\n      if (length(id.dups) > 0)\n        mo <- mo[-id.dups,]\n      # no problems with mo[-id.dups,]\n      # the two dimensions of a matrix are kept in data.frame \"mo\" even if\n      # \"mo\" contains one element after removing duplicates\n    }\n\n    ##FIXME\n    #at this point it could be checked for consecutive outliers of a given type\n    #and keep the one detected in a previous iteration\n    #if (nrow(mo) > 0 && iter > 0)\n    #tmp <- rbind(mo, moall)\n    #rmid <- c(\n    #  find.consecutive.outliers(tmp, \"IO\"),\n    #  find.consecutive.outliers(tmp, \"AO\"),\n    #  find.consecutive.outliers(tmp, \"LS\"),\n    #  find.consecutive.outliers(tmp, \"TC\"),\n    #  find.consecutive.outliers(tmp, \"SLS\"))\n    #print(rmid)\n\n    if (!is.null(logfile))\n    {\n      msg <- paste(\"\\noloop, iteration:\", iter, \"\\n\")\n      cat(msg, file = logfile, append = TRUE)\n      capture.output(mo, file = logfile, append = TRUE)\n    }\n\n    # this must be here, not before the previous \"if\" statement\n    # since it may modify \"mo\"\n\n    if (nrow(mo) == 0)\n      break\n\n    moall <- rbind(moall, mo)\n\n    # remove the effect of outliers on the data and\n    # fit the model for the adjusted series\n\n    oeff <- outliers.effects(mo = mo, n = n, weights = TRUE,\n                             delta = delta, pars = pars, n.start = n.start, freq = s)\n\n    # 'y' is overwritten; 'oeff' is based on 'mo' not 'moall'\n\n    y <- y - rowSums(oeff)\n\n    switch(tsmethod,\n           ##FIXME\n           #if 'fit' includes intercept or drift, pass here (it could be done based on names of coef(fit))\n\n           # do not modify and evaluate the call, i.e. do not run eval(fit$call)\n           # since it will run the model selection procedure (if tsmethod = \"auto.arima\")\n           # here we only want to refit the model (not choose or select a model)\n\n           \"auto.arima\" = fit <- arima(y, order = fit$arma[c(1,6,2)],\n                                       seasonal = list(order = fit$arma[c(3,7,4)])),\n\n           # this reuses arguments passed to the optimization method, e.g. method = \"CSS\",\n           # if they were specified when the input object \"fit\" was created,\n           # (for example through argument \"args.tsmethod\" of function \"tso\")\n\n           \"arima\" = {\n             fitcall <- fit$call\n             fitcall$x <- y\n             # rename fitcall$series since it can be a very long character string to store\n             #fitcall$series <- \"x\"\n             fit <- eval(fitcall)\n           },\n\n           \"stsm\" = {\n             fitcall <- fit$call\n             ##NOTE\n             # fitcall$x contains the model, not fitcall$m, since now \"stsmFit\" is called\n             # instead of \"maxlik.td.optim\" and the other functions\n             fitcall$x@y <- y\n             dy <- fitcall$x@fdiff(y, frequency(y))\n             fitcall$x@diffy <- dy\n             if (!is.null(fitcall$x@ssd))\n               fitcall$x@ssd <- Mod(fft(as.numeric(dy)))^2 / (2*pi*length(dy))\n             ##NOTE\n             #last parameter estimates, fit$pars, could be used as starting values\n             #fitcall$x@pars[] <- fit$pars\n             fit <- eval(fitcall)\n           }\n    )\n\n    if (!is.null(logfile))\n    {\n      msg <- paste(\"\\nmodel chosen and fitted for the adjusted series:\\n\")\n      cat(msg, file = logfile, append = TRUE)\n      capture.output(fit, file = logfile, append = TRUE)\n    }\n\n    iter <- iter + 1\n  } # end while\n\n  if (iter == maxit)\n    warning(paste(\"stopped when\", sQuote(\"maxit.oloop = 4\"), \"was reached\"))\n\n  # time points with multiple types of potential outliers are not expected\n  # since they are removed at each iteration\n  # stopifnot(!any(duplicated(moall[,\"ind\"])))\n\n  if (any(duplicated(moall[,\"ind\"])))\n  {\n    # stop for debugging\n    # so far this event has not occurred\n    stop(\"unexpected duplicates since they are handled within the loop above\")\n  }\n\n  # \"coefs\" is not actually used but keep so far, it may used to see\n  # the estimates for external regressors \"xreg\" which are not included in \"pars\"\n\n  list(fit = list(coefs = coef(fit), pars = pars,\n                  resid = resid, n = n), outliers = moall, iter = iter)\n}\n",
    "created" : 1497475025977.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "327833266",
    "id" : "E9B9742D",
    "lastKnownWriteTime" : 1497476064,
    "last_content_update" : 1497476064605,
    "path" : "~/tsoutlier/R/outlier_detection.R",
    "project_path" : "R/outlier_detection.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}